# 数据结构与算法

## 01 复杂度：如何衡量程序运行的效率？

### 复杂度是什么？

复杂度是衡量代码运行效率的重要度量因素。

### 时间复杂度与代码结构的关系

> - 一个顺序结构的代码，时间复杂度是 O(1)。
> - 二分查找，或者更通用地说是采用分而治之的二分策略，时间复杂度都是 O(logn)。
> - 一个简单的 for 循环，时间复杂度是 O(n)。
> - 两个顺序执行的 for 循环，时间复杂度是 O(n)+O(n)=O(2n)，其实也是 O(n)。
> - 两个嵌套的 for 循环，时间复杂度是 O(n²)。
>

### 总结

复杂度通常包括时间复杂度和空间复杂度。在具体计算复杂度时需要注意以下几点。

> - **它与具体的常系数无关**，O(n) 和 O(2n) 表示的是同样的复杂度。
> - **复杂度相加的时候，选择高者作为结果**，也就是说 O(n²)+O(n) 和 O(n²) 表示的是同样的复杂度。
> - **O(1) 也是表示一个特殊复杂度**，即任务与算例个数 n 无关。

复杂度细分为**时间复杂度**和**空间复杂度**，其中时间复杂度与**代码的结构设计**高度相关；空间复杂度与代码中**数据结构的选择**高度相关。会计算一段代码的时间复杂度和空间复杂度，是工程师的基本功。

## 02  数据结构：将“昂贵”的时间复杂度转换成“廉价”的空间复杂度

### 时间昂贵、空间廉价

代码效率的瓶颈可能发生在时间或者空间两个方面。如果是缺少计算空间，花钱买服务器就可以了。这是个花钱就能解决的问题。相反，如果是缺少计算时间，只能投入宝贵的人生去跑程序。即使你有再多的钱、再多的服务器，也是毫无用处。相比于空间复杂度，时间复杂度的降低就显得更加重要了。因此，你会发现这样的结论：空间是廉价的，而时间是昂贵的。

### 程序优化核心思路

**第一步，暴力解法（一个一个试）**。在没有任何时间、空间约束下，完成代码任务的开发。

**第二步，无效操作处理**。将代码中的无效计算、无效存储剔除，降低时间或空间复杂度。

**第三步，时空转换**。设计合理数据结构，完成时间复杂度向空间复杂度的转移。

### 降低复杂度的案例

**例1：**假设有任意多张面额为 2 元、3 元、7 元的货币，现要用它们凑出 100 元，求总共有多少种可能性

```java
public void s2_1() {
    int count = 0;
    for (int i = 0; i <= (100 / 7); i++) {
        for (int j = 0; j <= (100 / 3); j++) {
            for (int k = 0; k <= (100 / 2); k++) {
                if (i * 7 + j * 3 + k * 2 == 100) {
                    count += 1;
                }
            }
        }
    }
    System.out.println(count);
}
```

经过改造后，代码的结构由 3 层 for 循环，变成了 2 层 for 循环。很显然，时间复杂度就变成了O(n²)**（无效操作处理）**

```java
public void s2_2() {
    int count = 0;
    for (int i = 0; i <= (100 / 7); i++) {
        for (int j = 0; j <= (100 / 3); j++) {
            for (int k = 0; k <= (100 / 2); k++) {
                if ((100-i*7-j*3 >= 0)&&((100-i*7-j*3) % 2 == 0)) {
                    count += 1;
                }
            }
        }
    }
    System.out.println(count);
}
```

**例2：**查找出一个数组中，出现次数最多的那个元素的数值。例如，输入数组 a = [1,2,3,4,5,5,6 ] 中，查找出现次数最多的数值

```java
public void s2_3() {
    int a[] = { 1, 2, 3, 4, 5, 5, 6 };
    int val_max = -1;
    int time_max = 0;
    int time_tmp = 0;
    for (int i = 0; i < a.length; i++) {
        time_tmp = 0;
        for (int j = 0; j < a.length; j++) {
            if (a[i] == a[j]) {
            time_tmp += 1;
        }
            if (time_tmp > time_max) {
                time_max = time_tmp;
                val_max = a[i];
            }
        }
    }
    System.out.println(val_max);
}
```

在这段代码中，采用了两层的 for 循环，很显然时间复杂度就是 O(n²)。而且代码中，几乎没有冗余的无效计算。如果还需要再去优化，就要考虑采用一些数据结构方面的手段，来把时间复杂度转移到空间复杂度了**（时空转换处理）**

```java
public void s2_4() {
    int a[] = { 1, 2, 3, 4, 5, 5, 6 };
    Map<Integer, Integer> d = new HashMap<>();
    for (int i = 0; i < a.length; i++) {
        if (d.containsKey(a[i])) {
            d.put(a[i], d.get(a[i]) + 1);
        } else {
            d.put(a[i], 1);
        }
    }
    int val_max = -1;
    int time_max = 0;
    for (Integer key : d.keySet()) {
        if (d.get(key) > time_max) {
            time_max = d.get(key);
            val_max = key;
        }
    }
    System.out.println(val_max);
}
```

## 03 线性表

**例1:**链表的翻转。给定一个链表，输出翻转后的链表。例如，输入1 ->2 -> 3 -> 4 ->5，输出 5 -> 4 -> 3 -> 2 -> 1

这个问题的难点在哪里，这里有两种情况：

- 如果是数组的翻转，这会非常容易。原因在于，数组在连续的空间进行存储，可以直接求解出数组的长度。而且，数组可以通过索引值去查找元素，然后对相应的数据进行交换操作而完成翻转。
- 但对于某个单向链表，它的指针结构造成了它的数据通路有去无回，一旦修改了某个指针，后面的数据就会造成失联的状态。为了解决这个问题，我们需要构造三个指针 prev、curr 和 next，对当前结点、以及它之前和之后的结点进行缓存，再完成翻转动作。具体如下图所示：

![image020.gif](https://s0.lgstatic.com/i/image/M00/12/FE/Ciqc1F7OVEaAOjblAGtskMyw3Cc079.gif)

~~~java
while(curr){
    next = curr.next;
    curr.next = prev；
    prev = curr;
    curr = next;
}
~~~

**例2：**给定一个奇数个元素的链表，查找出这个链表中间位置的结点的数值

- 一个暴力的办法是，先通过一次遍历去计算链表的长度，这样我们就知道了链表中间位置是第几个。接着再通过一次遍历去查找这个位置的数值。
- 除此之外，还有一个巧妙的办法，就是利用快慢指针进行处理。其中快指针每次循环向后跳转两次，而慢指针每次向后跳转一次。如下图所示。

![HXedFIfmxfCLqrRI.gif](https://s0.lgstatic.com/i/image/M00/13/0A/CgqCHl7OVjSAOebFABlVpq6d7m0547.gif)

~~~java
while(fast && fast.next && fast.next.next){
    fast = fast.next.next;
    slow = slow.next;
}
~~~



